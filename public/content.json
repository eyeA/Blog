{"meta":{"title":"eyea","subtitle":"Nice to see you here!","description":"为了更优雅的生活","author":"eyea","url":"https://eyea.github.io/blog","root":"/blog/"},"pages":[{"title":"关于我的那点事儿","date":"2017-02-24T13:40:57.000Z","updated":"2019-04-18T08:35:31.204Z","comments":true,"path":"about/index.html","permalink":"https://eyea.github.io/blog/about/index.html","excerpt":"","text":"关于我的故事，先听几首歌曲吧，晚点回来补齐。沟通交流：deyesea@gmail.com"},{"title":"","date":"2017-01-04T15:54:16.000Z","updated":"2019-04-18T08:35:31.204Z","comments":true,"path":"categories/index.html","permalink":"https://eyea.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"阅读","date":"2017-01-04T15:57:11.000Z","updated":"2019-04-18T08:35:31.206Z","comments":true,"path":"reading/index.html","permalink":"https://eyea.github.io/blog/reading/index.html","excerpt":"","text":"阅读"},{"title":"","date":"2017-02-25T03:57:28.000Z","updated":"2019-04-18T08:35:31.207Z","comments":true,"path":"tags/index.html","permalink":"https://eyea.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2017年小结","slug":"2017年小结","date":"2018-01-03T02:26:49.000Z","updated":"2019-04-18T08:35:31.201Z","comments":true,"path":"2018/01/03/2017年小结/","link":"","permalink":"https://eyea.github.io/blog/2018/01/03/2017年小结/","excerpt":"那些在过去来不及但很想要做的事情，就现在做吧！ by eyeseau","text":"那些在过去来不及但很想要做的事情，就现在做吧！ by eyeseau 时间过得是真的很快，感叹2017年到末尾的是在几个小事情发生的时候触动的。一件是一个小游戏的突然发布，试玩了两次，然后对实现比较好奇 ㄟ( ▔, ▔ )ㄏ，年纪上来了，对新鲜的东西，总会有点下意识的去想知道为什么会是这样，怎么去实现的，而不是一脑子扎进去就开始体验和玩。但那两天恰好元旦，在丈母娘家，也总不能自己待在小屋子里对着电脑敲敲敲吧，电脑带着，也只有晚上进被窝的时候，打开github随便看看。另一件事情是朋友圈的网易云音乐的刷屏和18岁的照片。你看，是不是有点膈应人，哈哈 2017,其实还是发生了点事情的。 大概地说就是，换了一份工作，生了两场病，做了一次手术。老铁你看，是不是有点扎心？ 工作换工作是在年初就有的想法，当时有这个想法很简单，老东家开发的工作已经近乎停止了，上层领导班子不稳定，部门合并又拆分，办公地点搬过来搬过去。在中关村上班，每天骑着个自行车就可以，距离我很喜欢，地点我也很喜欢，那里很繁华，但是我还是要生活的，也不是一人吃饱，全家不饿。在短暂的小纠结后，还是选择了新的机会，距离也还好，三四站地铁，但很忙。在儿童节那天，入职新公司，看到了一个小时候很喜欢的明星，是的，就在10米的范围内，有点激动，但是我却在捣鼓IT同事给我的windows电脑，很不习惯。 在新的公司，昏天黑地了好几个月。 好一段日子，对框架只在知道的层面上，对于直接撸项目的我来说，不得不回去12点1点，然后在小阳台上看到3点多，迷迷糊糊又不安得睡下，早上八点多起床，十点上班的作息，我八点半就能到。但这不是一个好的作息，时间长了，对效率没有任何帮助。 还好，在12月份的一个礼拜日，粗心的HR给漏掉发邮件的我发了转正邮件。心想，这也算是入职后的一个小的奖励吧。 生活无头忙碌的日子，最是累，也最闹心。胃病复发了，吃了两三个月的药，好多了；还有一个小病，要治疗一年，天天吃药，半个月一检查；十月份的一个深夜的急性阑尾炎，不得不去做了个手术，做手术的上午，给家里的老妈打了个电话，说过来陪陪我，下午要做个小手术，当时妈妈正在洗手，擦也没擦，午饭也没吃，就过来了，又一次让家里担心了，身在远方，家，永远是我们最后的依靠，最温暖的港湾。 那天我记得很深，穿上病号服，躺在床上，等着手术刀。麻醉师把我推进手术室的时候，女朋友也在。看着她关心的眼神，我很安静。手术台是一个窄小的床，我问医生，不绑着我点么，我担心会疼的hold不住，摔下去会很疼的… 事实上我多虑了，麻药一打进来，我就睡着了。当他们做完后，我很精神的醒来，很开心的对他们说，辛苦了医生。后来才了解到一点，我对麻药吸收的太快了，迷糊的早，醒的也早了… 后来女友去车站接妈妈过来，我愣是没有睡，身边没有人，不相信这些护士。他们眼中的小病，可能对某些人来说，是生命层级的痛。妈妈跟女友来了，我睡了一天一夜。 感谢妈妈，感谢我的女朋友。 驾校时间今年就到期了，好像三年了，断断续续的还停留在科目二，我不喜欢开车。 另外一个好消息，现在暂不说吧~ 结束是最好的开始年轮在一圈又一圈的画着，身边的故事也在一件又一件的发生着。似乎年纪越大，我们身边的人和事就越不简单，仔细琢磨，各自有不同的味道。 结束是最好的开始，做好自己，就是不辜负。 我会继续安静着，看周遭的那些人情冷暖的更迭，喝着杯热水，在或雪或阳的窗台，在喜欢的电脑前，敲下一行行跳动的美丽的符号，或者，结伴为数不多的好友，一起做点好吃的，喝点小酒，聊着最近各自发生的故事。","categories":[],"tags":[]},{"title":"初识vim","slug":"初识vim","date":"2017-12-07T08:03:11.000Z","updated":"2019-04-18T08:35:31.200Z","comments":true,"path":"2017/12/07/初识vim/","link":"","permalink":"https://eyea.github.io/blog/2017/12/07/初识vim/","excerpt":"所剩时日无多，更加心平气和，也更加珍惜每一天的每一次。 学习资料 链接","text":"所剩时日无多，更加心平气和，也更加珍惜每一天的每一次。 学习资料 链接 Issues vi 进入Normal模式后，更改模式为Insert后，每一次键盘的hit会报类似的错误：UltiSnips#TrackChange: 解决方案 1234brew install opensslbrew link openssl --forcebrew uninstall pythonbrew install python --with-brewed-openssl 更多的关于vim的知识，记录在这里 Github","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://eyea.github.io/blog/tags/vim/"}]},{"title":"记一次在AWS上VPS搭建网站的一些事","slug":"记一次在AWS上VPS搭建网站的一些事","date":"2017-05-09T13:47:18.000Z","updated":"2019-04-18T08:35:31.199Z","comments":true,"path":"2017/05/09/记一次在AWS上VPS搭建网站的一些事/","link":"","permalink":"https://eyea.github.io/blog/2017/05/09/记一次在AWS上VPS搭建网站的一些事/","excerpt":"生活再不如意，心里也要微笑着。","text":"生活再不如意，心里也要微笑着。 个人网站刚开始诞生的时候，在阿里云上买的域名，记得还有一个虚拟主机，开心了一年，续费之后，觉得总是一大堆文件 ftp 或者别的工具直接到主机上，也没有数据库啊，后台环境这些个配置，什么WordPress，hexo(目前这个blog正在采用的)，没什么意思。正好最近闲的蛋疼，其实是心里烦躁的很，突然看到半年前注册的AWS，12个月的 VPS 对于我来说可是重新认识了。我之前傻傻分不清楚 虚拟主机跟虚拟服务器的区别，但是看过之后，瞬间觉得aws的这个12个月的体验简直是我等屌丝的福音啊，果断的搞起来。以下内容涉及的入门，是到发稿时候我的进度，挨着来的，通过啃文档，请教大神零星总结的。 账号首先得有一个账号吧。反正这个之前呢，你的 梯子 一定要稳定啊！不稳的话，访问下这个。相关信息的录入我就不多说了，提醒的一点是要绑定你的信用卡，我这次是扣取了2美元，汇率都6.9了…据说之后会返还的，但是即使不返还，2个大洋，12个月的vps，偷着乐吧。 实例然后右上角 我的账户 –&gt; AWS管理控制台 选择所有服务下的 EC2 ，进入后在 创建实例 下，点击 启动实例 按钮，进入后记得勾选左侧的 仅免费套餐 哦，我选择的是默认的第一个(我这个假后台不知道这些知识)，然后… 我要是一个输入框的说，我自己都会烦的。 配置建好一个实例之后，打开命令行这里稍后我会补充… 域名如果你是在阿里云上备案的域名，那就进入域名解析(举例子，你想要来个www.eyeseau.com)，添加一个解析。记录类型是 CNAME ,主机记录 www ,记录值是刚才你新建的实例的公网IP，然后保存就好了，现在就可以访问你的网站了。 后续我会更新自动化部署，github，建议先看看文档，这部分新手有点麻烦。。。","categories":[],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://eyea.github.io/blog/tags/AWS/"},{"name":"VPS","slug":"VPS","permalink":"https://eyea.github.io/blog/tags/VPS/"},{"name":"node","slug":"node","permalink":"https://eyea.github.io/blog/tags/node/"},{"name":"nginx","slug":"nginx","permalink":"https://eyea.github.io/blog/tags/nginx/"}]},{"title":"资源和文章","slug":"资源和文章","date":"2017-04-24T02:30:40.000Z","updated":"2019-04-18T08:35:31.199Z","comments":true,"path":"2017/04/24/资源和文章/","link":"","permalink":"https://eyea.github.io/blog/2017/04/24/资源和文章/","excerpt":"任何被动的痛苦，都没法给人带来进步，你的痛苦倒是可能给老板带来更多收入。 分享，是为了受益更多的朋友。","text":"任何被动的痛苦，都没法给人带来进步，你的痛苦倒是可能给老板带来更多收入。 分享，是为了受益更多的朋友。 从这里开始，我会不定时的更新这篇文章，用于记录日常工作和学习中遇到的好的文章、网站、视频、常识…甚至不限于一个链接。侧重于思维、逻辑、还有方法论这些方面，但不局限于，可能你会看到费德勒呢！我知道，我们每一个人都想要一份新鲜的食物，需要如同沐浴春风的感觉，喜欢猎奇，喜欢欣赏，喜欢享受…如果，你和我一样~ 网站 谷歌学术 文章 前端的自我修养 印象比较深的是那句 You are the owner of your career. 知识和能力。 一定要主动去建立自己的知识体系。在知识部分，分为两部分，一是标准，而是技术。如何建立自己的知识体系：第一步，寻找线索，确定要学的知识点，找标准文档和附录，找源代码，找最初的争议。第二步，建立联系。第三步，分类，建立联系以后，我们依据知识之间的联系，进行分类，就可以得到一张图谱，在这个图里面，我们就可以非常清楚地知道，哪些知识，是非常重要的，哪些，其实是可以互相替代的。第四步，追本溯源，当我对一个知识体系的全貌有了概念以后，占了全面两个字，接下来需要确认它的准确性。很多知识，在社区，会有很多的争议，该相信谁呢，这是个问题。而我的答案，就是追本溯源，去找它最初的讨论和定义。除了 wiki-google 学术搜索的组合，还有一些邮件列表和 github 提交历史，也是非常适合去查证一些概念和技术的历史的。最后说，我讲的这个建立知识体系的过程，是不断接受新知识，挑战、质疑原有的体系，推翻再重建，每一次循环，你的知识体系都变得更加坚固，更加强大。 还有就是能力的培养，重点是要去教材，训练。能力部分的比重占据80%，分别是 编程能力 ，就是用代码解决问题的能力，编程能力越强，面对越复杂的问题就会越得心应手，编程能力有细分调试、算法、数据结构、OS原理等。架构能力 ，则是解决代码规模的问题，当一个系统足够复杂，你会写每一块，能解决每一个问题，不等于你能搞定整个系统，这就需要架构能力，架构能力包含了一些意识，比如解耦、接口隔离，也包含认识业务建立抽象模型，也有一些常见的模式，比如经典的 MVC，还有设计层面，面向对象、设计模式等等。最后 工程能力，则是解决协作的问题，当系统规模更大，光靠一个人，是没办法完成的，如何保证几个高手互相能够配合好？如何保证项目里面水平最差的人不拖后腿？这个工程化建设，往往会跨越多个业务，以汇报关系上的团队为单位来做。包括前后端解耦，模块化，质量保证，代码风格，等等。 任何被动的痛苦，都没法给人带来进步，你的痛苦倒是可能给老板带来更多收入。 (持续更新ing…)","categories":[{"name":"resources","slug":"resources","permalink":"https://eyea.github.io/blog/categories/resources/"}],"tags":[{"name":"resource","slug":"resource","permalink":"https://eyea.github.io/blog/tags/resource/"}]},{"title":"发布Node模块到NPM社区(es625原始包发布案例)","slug":"发布Node模块到NPM社区","date":"2017-03-31T04:09:40.000Z","updated":"2019-04-18T08:35:31.198Z","comments":true,"path":"2017/03/31/发布Node模块到NPM社区/","link":"","permalink":"https://eyea.github.io/blog/2017/03/31/发布Node模块到NPM社区/","excerpt":"作为前端你不会nodejs怎么行？ 如果没有业务驱动，那么最好自我驱动！","text":"作为前端你不会nodejs怎么行？ 如果没有业务驱动，那么最好自我驱动！ 关于Nodejs这个00后来说，从12年开始火，然后点亮了整个生态圈。nodejs的个人信息，需要的去看官方文档。 这里假设的是你已经配置了nodejs环境，本文环境如下：1234eyeseau:~ eyea$ node -vv6.9.1eyeseau:~ eyea$ npm -v3.10.8 目的是简单的走一个制作一个npm包的简单流程，在 npm社区 这个庞大的社区里，共享你的知识成果。 1.初始化一个项目12mkdir npm &amp;&amp; cd npm // 新建一个npm项目然后进入npm init // 初始化项目 紧接着开始配置，包括项目名称，版本号，项目描述，入口文件，关键词，作者等信息，配置 license 后，会让你确认信息，通过后，我们便有了 package.json 文件，用来提供项目信息和依赖信息。 注意的是： 1）npm包名要去小写； 2）版本号类似于 v1.0.0 ，后续不同程度的更新，是有区别的： 版本格式：主版号.次版号.修订号，版号递增规则如下： 主版号：当你做了不相容的 API 修改， 次版号：当你做了向下相容的功能性新增， 修订号：当你做了向下相容的问题修正。 先行版号及版本编译资讯可以加到「主版号.次版号.修订号」的后面，作为延伸。 3）入口文件需要我们把组件暴露出去的，以供用户导入(这是用户访问你的npm包的唯一入口)；es625 这个是我们本次案例，目的是为了刚接触es6语法的同学学习，在做demo过程中和es5来进行直观的代码对比，同时建议结合es6API或者 教程 ，更深入体会 es6 的强大。 2.依赖文件配置我们依赖了es6toes5鼻祖 babel，以及 Gulp 打包工具，所以有以下依赖：1234\"gulp\": \"^3.9.1\",\"gulp-babel\": \"^6.1.2\" ,\"babel-preset-es2015\": \"^6.24.0\",\"babel-plugin-transform-es2015-modules-amd\": \"^6.24.0\" 需要你在 cmd 敲打一下命令：123npm install gulp gulp-babel babel-preset-es2015 babel-plugin-transform-es2015-modules-amd --save// --save-dev 是你开发时候依赖的包,--save 是你发布之后仍然依赖的包。// 如果你爬梯子费劲，建议换成 cnpm。 这时打开你的 package.json 会多出配置项 dependencies 。 现在我们要开始使用gulp了，新建并配置 gulpfile.js :12touch gulpfile.js &amp;&amp; vi gulpfile.js// 或者就进入编辑器操作文件，都可以 具体编辑工作是这样的：12345678var gulp = require('gulp');var babel= require('gulp-babel');gulp.task('es625', function()&#123; return gulp.src('src/**/*.js') //ES6 file named \"src\" .pipe(babel()) .pipe(gulp.dest('dist')); //result of ES6(named \"dist\") to ES5&#125;); 上面的 require 仿佛看到了用户使用我们制作的npm包的情景(不过es625目前版本v1.0.3只提供转换功能，并没有export哦) 既然使用了 babel 的‘翻译’功能，那么就得有这样的一个文件：1234// .babelrc&#123; \"presets\": [\"es2015\"]&#125; 经常使用 Git 的我们一定会记得 .gitignore ，那么npm也有同样的功能的file，不过名字是 .npmignore ，看个人需求了，不过本地开发，肯定会有测试文件，依赖文件，错误日志等，我们在本地留存就好了，没必要上传到包里。 3.README.md这个文档是很重要的，相当于发布包的说明书作用，介绍，用法，版本更新日志等，所以单独列出来。 4.发包首先你有个 npm账号 或者 命令行形式注册:123npm adduserUsername:Password: 然后发布前，确认下：12npm whoamieyeseau OK后，1npm publish 至此，我们已经完成一个包的简单制作以及发布路程，去 npm社区 看下自己包包吧。 （本文完）","categories":[{"name":"Node","slug":"Node","permalink":"https://eyea.github.io/blog/categories/Node/"},{"name":"npm","slug":"Node/npm","permalink":"https://eyea.github.io/blog/categories/Node/npm/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://eyea.github.io/blog/tags/Node/"}]},{"title":"移动端适配方案二","slug":"移动端适配方案二","date":"2017-03-30T02:02:10.000Z","updated":"2019-04-18T08:35:31.198Z","comments":true,"path":"2017/03/30/移动端适配方案二/","link":"","permalink":"https://eyea.github.io/blog/2017/03/30/移动端适配方案二/","excerpt":"续上篇 移动端适配方案一 ，了解了关于 视口 和 像素 之后，我们继续关于适配。 适配的一切，都要忠于设计稿。","text":"续上篇 移动端适配方案一 ，了解了关于 视口 和 像素 之后，我们继续关于适配。 适配的一切，都要忠于设计稿。 我只讲我用过的rem布局方案 登场，目前我采用的方案是这样的(如无特别说明，以下的尺寸均是指宽度): 1.已经和设计师沟通好设计稿的尺寸为750px；2.前端这里以375px的6为依据(初始化宽度)，初始化html的fontSize为100px(方便计算)，采用理想视口：1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; 看着很暴力，嗯。。。对。。。依旧举个例子，设计稿上一个元素的尺寸是16px；那么在生成过程中，我们会转化成0.08rem；以上，便是适配的过程。 用过的要思考当我们通过一个简单的操作就可以把产品推送到百万级的用户面前的时候，应该体会到的是，科技赐予我们的力量。下面分析下上述原理。所有的假设都会有一个前提，这里的前提，忘记了往上看。如果你跟设计师沟通好了，恰好跟我的情况一致，那恭喜，方案伸手即可用；如果是别的640，甚至是1242的，那么继续往下看。针对6的，我们解决了，那么如果是6plus、4的呢 给你瞅个眼花缭乱的 。这里我们加了段js，用来响应不同尺寸的屏幕对应的根元素基准值，大概意思是这样的： 12345var initWidth = 375, initSize = 100, w = window.innerWidth, fixScreen = w/initWidth*initSize;document.documentElement.style.fontSize = fixScreen + \"px\"; 适配？交给js去吧，静态部分只需计算好设计稿的尺寸跟对应的css像素，别的dpr，ppi，lpi，视觉视口，理想视口，布局视口…bye 说我想说的理论部分，目前确实不擅长，各种名词和之间的逻辑关系。理解之后，我只用自己熟悉的语言来描述出来，加深记忆的同时，或许会帮助一些人。强烈建议看上一篇 移动端适配方案一 ，我开始继续逼逼。 这里我们可以假设dpr铺满“布局视口”的每一个像素点，那么也就是说此时的“布局视口”就是理想视口，就是视觉视口，简单理解就是1px=1dpr。 但是移动设备(这里主要是手机，pad等)，往往不能给我们展示出真正的布局视口，所以需要适配。也就类似在清明上河图上显示出北宋汴京社会全貌。同样是表示卖菜的商贩，图纸上可能就是一个点，而社会上可能就是一大片区域，区别就在于资源的限制。如果想要在视觉视口上表示出布局视口的所有内容，那么肯定的一点就是单位面积上可用来表示元素的资源密集了，轮廓我们就可以按照比例放小点了，因为他也可以表示的很清楚，丝毫不逊于布局视口的展现。 所给图纸的大小不一样，我们就需要不同的适配，用来表现同样的东西。 清明上河图只有一份，在故宫放着。一个团队开发的标准也只有一个，上面方案就是一个标准，然后不同画布我们根据标准来等比缩放，那么同样的数字和单位的结合，在不同的图纸上，表示的大小就可能会不一样，在A4上可能是16px，那么在A2图纸上可能就是32px，因为可用资源增多了嘛。 回过神来，设计稿是按照750px来设计的，元素是16px，那么设计师想要表达的是在750px的设备上展现的尺寸就是16个物理像素，在PC端，因为布局视口和视觉视口是一致的，我们不用适配，在移动端，不要高兴太早。同样表示的16个像素点，在6的375px下，表示设计稿元素同样的尺寸，因为其dpr为2，也就是说每个css像素，可以表示尺寸2个物理像素，所有自然而然的css像素就是8px了，没毛病。 这就是跟设计师沟通达成一致后的方案，皆大欢喜。 总结一下，我们确定基准6，然后结合 meta 和 javascript ，前者锁定理想视口，后者响应设备，重置根元素基准值。相关代码在来一遍：123456&lt;meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no'&gt;var initWidth = 375, initSize = 100, w = window.innerWidth, fixScreen = w/initWidth*initSize;document.documentElement.style.fontSize = fixScreen + \"px\"; （本文完）","categories":[{"name":"mobile","slug":"mobile","permalink":"https://eyea.github.io/blog/categories/mobile/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://eyea.github.io/blog/tags/移动端/"}]},{"title":"移动端适配方案一","slug":"移动端适配方案一","date":"2017-03-29T07:28:12.000Z","updated":"2019-04-18T08:35:31.197Z","comments":true,"path":"2017/03/29/移动端适配方案一/","link":"","permalink":"https://eyea.github.io/blog/2017/03/29/移动端适配方案一/","excerpt":"现在我们不谈PC，只聊移动端适配那些事儿。 不管是知道还是不知道，开发工具能够说明很多很多","text":"现在我们不谈PC，只聊移动端适配那些事儿。 不管是知道还是不知道，开发工具能够说明很多很多 看到这里时候，最好带上笔和纸，勾勾画画，或者打开控制台，切换成手机模式，just coding ! 从而形成一个大概的模型，方便理解。理解适配，先从两个概念入手：视口 和 像素 视口视口分为 布局视口 和 视觉视口。 1.布局视口 document.documentElement.clientWidth/Height 返回布局视口的尺寸。在移动端，布局视口(布局视口一般是980px)和屏幕宽度是完全独立的，他是由浏览器厂商来确定的视口(一般在768px~1024px之间)，为了让网页在窄屏幕上也能显示完整。我们使用meta标签的 meta 和 媒体查询 指的都是 布局视口。1234&lt;meta name='viewport' content='width=640'&gt;@media (min-width: 640px)&#123; font-size: 16px;&#125; 2.视觉视口window.innerWidth/Height 返回视觉视口的尺寸，指我们正在看到的网页的区域。这里需要补充的一点是有个 理想视口 的概念，对设备来讲是最理想的视口尺寸，即用户不需要额外的操作成本(缩放),即可获得最佳的查看网页外观效果。通常我们通过这样设定：123456&lt;meta name='viewport' content='width=device-width initial-scale=1'&gt;/*这里的initial-scale=1和width=device-width是一样的效果，兼容initial-scale，它会将布局视口也同步为缩放后的尺寸initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病*/ 让布局视口和设备理想尺寸宽度上保持一致。 像素像素分为 设备像素 和 css像素 1.设备像素屏幕的物理像素，对特定的设备来说，该值是固定不变的。 2.css像素也可以称为设备独立像素。js和css中一个抽象概念，单位px。当我们给一个 div 元素设置样式 width:10px 那么该元素实际的大小是多少呢？在移动设备上，一个元素的实际大小有这么两个因子影响着：是否缩放(initial-scale) 、屏幕的分辨率。我们知道了缩放是相对于布局视口来进行的。当在 dpr=2的并且放大2倍的设备上来说， 10px 表现为 40px(10px22)。我们定义的是css像素，然后浏览器内部会转换成对应多少设备像素来展示出来。这里引入一个 设备像素比(device pixel ratio) 即 dpr 。123dpr = 设备像素/css像素/*设备像素比也可以*/dpr = 屏幕横向设备像素/理想视口宽度 可以通过 window.devicePixelRatio 来得到该值。通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。在不缩放前提下，1px1px的元素在dpr=2上使用了22个设备像素，在dpr=3的设备上使用了33个设备像素，同样面积(1px1px)的区域使用的设备像素越多，就显示的越清晰。 参考文章@riskers 移动端适配方案(上)","categories":[{"name":"mobile","slug":"mobile","permalink":"https://eyea.github.io/blog/categories/mobile/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://eyea.github.io/blog/tags/移动端/"}]},{"title":"ThreeJS-相机","slug":"ThreeJS-相机","date":"2017-03-23T04:50:22.000Z","updated":"2019-04-18T08:35:31.197Z","comments":true,"path":"2017/03/23/ThreeJS-相机/","link":"","permalink":"https://eyea.github.io/blog/2017/03/23/ThreeJS-相机/","excerpt":"本篇文章是关于 Three.js 三维空间的观察，相机的概述。","text":"本篇文章是关于 Three.js 三维空间的观察，相机的概述。在Threejs中相机的表示是 THREE.Camera，它是相机的抽象基类，其子类有两种相机，分别是正投影相机 THREE.OrthographicCamera 和透视投影相机 THREE.PerspectiveCamera ,区分二者也很简单：透视投影有近大远小的特征，即同一个物体在远处一定是比在近处看的小的。而正投影，学习机械建筑的同学都知道，三视图嘛，远近比例是一致的。 透视投影相机这是今天主要介绍的对象。从生活经验来说，透视投影是更符合我们视觉的投影。横看成岭侧成峰，远近高低各不同。构造函数如下：1PerspectiveCamera( fov, aspect, near, far ) 说明： 1、视角fov：这个官方解释是： Camera frustum vertical field of view, from bottom to top of view, in degrees. Default is 50. 有种理解是：fov代表眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔,但是在180度的时候，往往物体很小，因为他在你的整个可视区域中的比例变小了。另外，人类的正常视角是120度左右，但是要集中注意力看清楚东西，那么眼睛的视角在30-40度比较好。视角越大，中间的物体越小，这是因为，视角越大，看到的场景越大，那么中间的物体相对于整个场景来说，就越小了。 2、近平面near：近值是指立方体离相机最近的点到相机的距离n的范围。也可以认为是眼睛距离近处的距离，不要设置为负值。 3、远平面far：远值这是指立方体中心到相机的距离s。 4、纵横比aspect：实际窗口的纵横比，即宽度除以高度。相机大小和渲染器尺寸要相等，否则就会变形，做好自己更改下参数看下效果。 (To be continued)","categories":[],"tags":[]},{"title":"ThreeJS-开篇","slug":"ThreeJS-开篇","date":"2017-03-22T03:20:39.000Z","updated":"2019-04-18T08:35:31.197Z","comments":true,"path":"2017/03/22/ThreeJS-开篇/","link":"","permalink":"https://eyea.github.io/blog/2017/03/22/ThreeJS-开篇/","excerpt":"3D的世界，多一个维度，多一点欢乐。","text":"3D的世界，多一个维度，多一点欢乐。 不多说的为什么要学，直接开搞还是来点前奏吧 Three.js, 相信看了这个官方API的同学，笼统的风格实在是着急，但也理解，作者精力都放在源码上去了，再说，慕名而来的Threejser们哪个智商低了？哈哈哈我准备把看过的关于Threejs的知识跟体会做成一个系列，高手多指点，小白多交流，共同进步。ps:评论多说我会抽时间来更换的,目前可以通过邮件 @eyea 联系或者Giteyea 源码的学习总是令人兴奋 ThreeJS三兄弟他们分别是 Scene 、 Camera 、 Renderer ,即 场景，相机，渲染器。这三兄弟将会把3D世界搞得有声有色~ 。 场景是用来容纳元素的，比如我们新建一个cube，一条line，一个star，都需要Scene.add()进来才能显示的，定义的size，position等才会有意义； 相机是定义可视区域，能够确定哪些图形元素是可以看得到的； 渲染器是…这个看名字，不多说,其实是代表的是 canvas 标签,现在的版本 85dev 使用的是WebGLRender来渲染的，但是存在有的机器上不支持WebGL. 他们三个创建也很简单，都是THREE.X的实例：12345678910111213var scene = new THREE.Scene(), camera = new THREE.PerspectiveCamera(), // 透视相机 renderer= new THREE.WebGLRender();// threejs提供的相机有正交相机（OrthographicCamera）、透视相机（PerspectiveCamera）、全景相机（CubeCamera）和3D相机（StereoCamera）。// 你想看见的元素必须要放在相机可视域中，当创建元素看不到了，检查下相机的 __position__ 、__lookAt(朝向)__ 和创建参数了。当然都是相对的，你也可以调整元素嘛。// 多说一句，创建相机都有 __near__ 和 __far__ 两个参数，近值是指立方体离相机最近的点到相机的距离n的范围，远值这是指立方体中心到相机的距离s。// 相机大小和渲染器尺寸要相等，否则就会变形，如果你需要失真变形，随意。// 知道渲染器是canvas标签后，setSize也是可以的 renderer.setSize(width, height);// 然后放入你指定的元素中 ele.appendChild(renderer.domElement); 下一篇，我们开始相机。先看个 例子 。 (To be continued)","categories":[{"name":"WebGL","slug":"WebGL","permalink":"https://eyea.github.io/blog/categories/WebGL/"}],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"https://eyea.github.io/blog/tags/WebGL/"},{"name":"ThreeJS","slug":"ThreeJS","permalink":"https://eyea.github.io/blog/tags/ThreeJS/"}]},{"title":"透明立方体","slug":"透明立方体","date":"2017-03-21T14:39:42.000Z","updated":"2019-04-18T08:35:31.197Z","comments":true,"path":"2017/03/21/透明立方体/","link":"","permalink":"https://eyea.github.io/blog/2017/03/21/透明立方体/","excerpt":"css探索之路是永无止境，并且充满乐趣的。今天我们来做一个透明的立方体，以及简单的介绍用到的css属性。","text":"css探索之路是永无止境，并且充满乐趣的。今天我们来做一个透明的立方体，以及简单的介绍用到的css属性。 前言为了便于对比，这里做了两组。提前预报一下，我们用到的属性有 backface-visibility , perspective , perspective-origin , transform-style , transform。一定要考虑到 兼容性。 ps:这里建议先看下css文档，然后再回过来看这篇文章，最好脑补或者写一遍，体会更深一些。 这里假设大家明白或者已经初步了解了上面的提示内容，简单的对上面的进行说明： backface-visibility 定义当元素不面向屏幕时是否可见，有两个值：visible 和 hidden； perspective 设置从何处查看一个元素的角度，该属性只影响 3D 转换元素，设置值的单位是像素px，表示元素距离视图的距离，应用在舞台元素上； perspective-origin 属性定义 3D 元素所基于的 X 轴和 Y 轴。默认值为中间位置，50% 50%；X轴向右为正，Y轴向下为正； transform-style 指定嵌套元素是怎样在三维空间中呈现。两个值plat和preserve-3d，后者表示3D透视。这个一般应用在舞台元素上； 上代码html部分的代码：12345678910&lt;div class=\"test-container\"&gt; &lt;div class=\"test-cube\"&gt; &lt;div class=\"test-face test-front\"&gt;1&lt;/div&gt; &lt;div class=\"test-face test-back\"&gt;2&lt;/div&gt; &lt;div class=\"test-face test-top\"&gt;3&lt;/div&gt; &lt;div class=\"test-face test-bot\"&gt;4&lt;/div&gt; &lt;div class=\"test-face test-left\"&gt;5&lt;/div&gt; &lt;div class=\"test-face test-right\"&gt;6&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css部分的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061.test-container&#123; width: 150px; height: 150px; margin: 75px auto;&#125;.test-cube&#123; width: 100%; height: 100%; backface-visibility: visible; --webkit-backface-visibility: visible; perspective: 300px; -webkit-perspective: 300px; perspective-origin: 150% 150%; --webkit-perspective-origin: 100% 100%; transform-style: preserve-3d; --webkit-transform-style: preserve-3d;&#125;.test-face&#123; width: 100px; height: 100px; line-height: 100px; text-align: center; font-size: 60px; color: white; position: absolute;&#125;/*单个页面*/.test-front&#123; background: rgba(0, 0, 0, 0.3); transform: translateZ(50px); -webkit-transform: translateZ(50px);&#125;.test-back&#123; background: rgba(0, 255, 0, 1); color: black; transform: rotateY(180deg) translateZ(50px); -webkit-transform: rotateY(180deg) translateZ(50px);&#125;.test-top&#123; background: rgba(196, 196, 0, 0.7); transform: rotateX(90deg) translateZ(50px); -webkit-transform: rotateX(90deg) translateZ(50px);&#125;.test-bot&#123; background: rgba(196, 0, 196, 0.7); transform: rotateX(90deg) translateZ(-50px); -webkit-transform: rotateX(90deg) translateZ(-50px);&#125;.test-left&#123; background: rgba(0, 0, 196, 0.7); transform: rotateY(-90deg) translateZ(50px); -webkit-transform: rotateY(-90deg) translateZ(50px);&#125;.test-right&#123; background: rgba(196, 0, 0, 0.7); transform: rotateY(90deg) translateZ(50px); -webkit-transform: rotateY(90deg) translateZ(50px); &#125; 再次强调需要注意的几个点： perspective 、 perspective-origin 、 transform-style 定义在舞台元素上； transform 定义在具体元素对象上； 空间想象力可以多练习下，先翻转后平移跟先平移后翻转，基准对象是不一样的，所以表现也会有差异的。 end","categories":[{"name":"CSS","slug":"CSS","permalink":"https://eyea.github.io/blog/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://eyea.github.io/blog/tags/CSS/"}]},{"title":"VR之A-FRAME接触1","slug":"VR之A-FRAME接触1","date":"2017-03-21T06:12:48.000Z","updated":"2019-04-18T08:35:31.196Z","comments":true,"path":"2017/03/21/VR之A-FRAME接触1/","link":"","permalink":"https://eyea.github.io/blog/2017/03/21/VR之A-FRAME接触1/","excerpt":"VR（Virtual Reality）是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以及时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界视频传回产生临场感。—— 维基百科","text":"VR（Virtual Reality）是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以及时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界视频传回产生临场感。—— 维基百科 webVR草案： WebVR 是早期和实验性的 JavaScript API，它提供了访问如 Oculus Rift 和 Google Cardboard 等 VR 设备功能的 API。 目前笔者接触过的方案,基本上近期内是离不开Three.js ,对于没有接触过它又想要体验一把webVR技术的（比如我）,无疑是有点难度的。有需求的地方，一定会有满足该需求的解决方案。显然，MozVR 团队 在这方面做得不错，他们开发了A-Frame框架，案例和文档 也是比较完善的,通过这个开源的框架构建的VR场景能够兼容PC、Mobile、Oculus Rift和HTC Vive，这个框架能够使我们能够快速的通过简单的html标签以及属性和JavaScript，让迫不及待的我们能够迅速体验到这一酷炫的技术，很赞！ 先睹为快，看下简单的 Hello World123456789&lt;script src=\"https://aframe.io/releases/0.5.0/aframe.min.js\"&gt;&lt;/script&gt;&lt;a-scene&gt; &lt;a-sphere position=\"0 1.25 -5\" radius=\"1.25\" color=\"#EF2D5E\"&gt;&lt;/a-sphere&gt; &lt;a-box position=\"-1 0.5 -3\" rotation=\"0 45 0\" width=\"1\" height=\"1\" depth=\"1\" color=\"#4CC3D9\"&gt;&lt;/a-box&gt; &lt;a-cylinder position=\"1 0.75 -3\" radius=\"0.5\" height=\"1.5\" color=\"#FFC65D\"&gt;&lt;/a-cylinder&gt; &lt;a-plane position=\"0 0 -4\" rotation=\"-90 0 0\" width=\"4\" height=\"4\" color=\"#7BC8A4\"&gt;&lt;/a-plane&gt; &lt;a-sky color=\"#ECECEC\"&gt;&lt;/a-sky&gt;&lt;/a-scene&gt; 简单的js文件引入，标签的建立，就可以实现简单的案例。当然，更多的 Demos 演示，还有他们的 Blog , 少不了Github Awesome A-Frame . 如果只是这样完事，那我就没必要搞这个文章了。昨晚到今天上午，萌萌呼呼的总结了点关于 VR体验环境 的搭建。下面步入本文的正题。 e神我最近常用的是mac，于是就啥也没想，一股脑子的就直奔主题，从Mozlia的a-frame文档，追到Oculus Rift(其实追到这里就应该有所察觉了，奈何英文渣，挨个来读介绍 QAQ)。是的，我已经下载了 FirefoxNightly ,不知道是哪里的原因，访问Mozlia出奇的慢，google翻的速度还行，70M的dmg愣是耗了一大会儿·(如果需要，联系我，文档下载两不误)。 一边看文档跟实例，当然这也在 W-A-S-D和上下左右键，空格键结合来体验那些demo，当时我在想着这些用 css 和 javascript ，即不依赖 Three.js 引入或者是 Aframe.js 就能实现。。你知道的，就去试着做demo，用来一部分css的动画属性。 没有对比就没有伤害，我果断抛弃了热乎乎刚写的代码，看文档跟体验去了– 我想说的一句是，当你对一个技术点特别感兴趣的时候，一定不要头脑发热，就好比遇到心仪的女孩子，不要猴急的表白许诺。好好看看文档，比如这一行： Unfortunately, Mac and Linux are not supported with the Oculus Rift and cannot be used for viewing WebVR content.当时我看到的时候，我已经被VR迷住了，对，就是傻劲，我计划的是把步骤走一遍，然后mac上装个windows系统(没错，Crazy…),要么就是用下 Docker … 当时就是这样想的。 第二天早早的到了公司，开始谷歌关于A-Frame的现状。Oculus Rift和HTC Vive Pre都相继公布了推荐PC配置，但引起大家好奇的一点就是这些配置都是针对Windows系统电脑的，难道就没有适合苹果Mac电脑的配置吗？Oculus创始人帕莫尔·勒基（Palmer Luckey）表示：苹果电脑的配置太烂了，没法支持VR头盔对PC性能的要求！ 帕莫尔·勒基解释说：“这主要是因为苹果并没有将高端GPU列为优先考虑的配置。你可以花6000美元买一台搭载顶级AMD Fire Pro D700处理器的Mac Pro，但它还是没有达到我们的推荐配置要求。如果他们像以前一样配置更高端的GPU，我们将很乐于为Mac提供支持。但是现在，还没有一台Mac电脑能够支持它，即便我们在软件方面为它提供支持，也没有能够运行大多数VR软件的Mac电脑。” 人家说的确实没错，苹果电脑采用的显卡性能都不是很理想，在MacBook系列中，也只有顶配的MacBookPro才有独立显卡。目前的VR产品对PC的图形处理有着苛刻的要求，最低显卡都是GTX 970级别的，所以苹果用户没法在第一时间体验到Oculus Rift和HTC Vive了。 消息是16年3月的。后来据说有个外置显卡的众筹项目，但是最后众筹失败。今年3月份，开发商Cindori推出一款名为VR Desktop for Mac的应用，使得MacOS也可以支持Oculus Rift，20刀，而且仅仅是只能支持 Oculus Rift。没办法，硬件限制，不能真正的支持 VR . 问题来了，我这低配的mac能跑起来吗？ 笑话。 果断的，我从书桌底层把布满灰尘的HP笔记本拿出来，这台哥们确实很单纯，重新装的win7，什么都没有。 于是梯子(现在没有梯子就看不到那些花花世界了)，Git(重要性不言而喻)，Nodejs(这个在这里目前不是必须的，习惯了)，还有win版本的FirefoxNightly，Chromium，我着重去了 Oculus 注册账号，看了下外设，顺便某东某猫上看了下价格。。。 额，重点在 这里 了, Getting Started part部分，正如你所看到的: Compatibility tool - Make sure your PC is Oculus ready. Rift Setup Tool - Download Rift’s setup tool to get started in virtual reality. Getting Started Guide - We’ll help you download the Oculus software, unbox your Rift, and personalize it. User Guide - Now that your Rift is all set up, you can download, purchase, and manage games and apps, both in Rift and on your computer’s desktop. Setup Videos - These videos show you how to setup your Rift. 上面的第一点是确保当前PC支持 Oculus Rift，第二点可以理解为VR外设驱动了。两个都是需要墙外去下载的。期间会需要你下载Micsoft的两个补丁(自行百度或者找我要),另外你需要邮箱来注册Oclus账号，因为后续结合设备来配置下参数的。 在VR配套设施具备后，有这么几个你可能想要体验的：sketchfab vizor Slackbeloola chromeexperiments 最后，想多余一句，如果是 i5 2.7GHz 和6100 1536 MB的mac话，还是换台win机吧，很烫。 （本文完）","categories":[{"name":"VR","slug":"VR","permalink":"https://eyea.github.io/blog/categories/VR/"}],"tags":[{"name":"VR","slug":"VR","permalink":"https://eyea.github.io/blog/tags/VR/"},{"name":"A-FRAME","slug":"A-FRAME","permalink":"https://eyea.github.io/blog/tags/A-FRAME/"}]},{"title":"知识付费随笔（一）","slug":"知识付费","date":"2017-02-28T07:20:05.000Z","updated":"2019-04-18T08:35:31.195Z","comments":true,"path":"2017/02/28/知识付费/","link":"","permalink":"https://eyea.github.io/blog/2017/02/28/知识付费/","excerpt":"最近经常在耳朵边环绕的词语就是：知识付费，内容创业。","text":"最近经常在耳朵边环绕的词语就是：知识付费，内容创业。 很小的时候，我们就接触诸如“知识就是财富”、“知识就是生产力”这样的那样的知识，告诉我们只要掌握了科学文化知识，就能过上幸福美满的小康生活。是的，或许有很多人跟我一样，发现我们从小学到大学，所学到的所谓知识，从步入社会之后，发现很严重的“脱节”！我们在小埋怨之后，还不得不面对现实进行反思：我考取的工信部认证的设计师资格，我考过的英语6级，我学到的那些历史，挑灯夜战的CAD作图，黑眼圈来完成的毕业论文，心惊胆战的答辩。。。这些到底，到底跟现在我的工作有一分钱的关系吗？还不如那些早早进入社会拼搏的小伙伴们生活的滋润，还不如那些专注网络游戏的大神们挣的钱多，还不如。。。是的，还有一波“还不如”，写不完的不如，道不尽的苦水。心高气傲的我们刚开始总是会觉得自己高人一等，但是在打开窗户，呼吸到精彩的外面世界的空气之后，发现，如果继续一如既往，如果不寻求改变的机会，真的就废了。屋漏偏逢连夜雨，从去年开始到今年伊始，经济变得沉闷，市场变得很浑浊，商业还是那么浮躁，还好我相信，总有一些人需要良好的秩序跟环境，总是需要一些来自北极的冰块来镇静下这片燥热的土地。说到知识付费，我最先了解的是著名评论人keso发帖跟马总跟帖的截图，微信要加快推出付费订阅的功能，然后开始了解到，从2016到今天，行/分答、知乎live、喜马拉雅、吴晓波频道、钛媒体、36氪等先后推出各自不同内容的付费产品，再到最近本人也跟风的加入的付费圈子，有了一些实质性的体会。 诚如所见，付费迎来了春天，很多的内容收割者获得了不菲的收入，让我看到了人们对知识、对内容的渴求欲望，也引起了我对知识付费的思考。付费形式能够走起来，有几点原因： 1.海量的信息时代，缺少的是高质量的内容。种类繁多的搜索方式，app入口，短信推送。。。接收信息的入口增多，时间的碎片化使得我们对这些铺天盖地而来的信息获取渠道产生了注意力分散，信息的冗余，不能简单高效的获取到真正我们需要的信息资源。我们都知道时间的宝贵性，如果你上半年有能力去买房，但是还在观望，四方打听，迟迟不肯下手，当忙完空余，蓦然回首，年底便是成倍的成本增加，去年某个城市就是如此。成本的增加源于我们对信息获取能力的匮乏，排除个人因素，单是各种无效分析评论和噱头性质的文章让很多人存在着一些侥幸心理，然而，我把这些归于无效信息的严重泛滥，我们在比较，分析时候，不仅来自个人过去经历，更多的是想要与时俱进，从各大网站，各个APP,订阅，杂志媒体等各方面去分析，比较，但处于这些对象的先天自私属性，处于经营，效益等方面的考虑，提供了很多重复，不同程度的信息给我们，最终的导致是无法去精准的的判断和验证某个想法的正确性，导致一些追悔莫及的失误。当然，这只是众多例子中一朵小浪花。 2.知识作为了新的商品入口，知识的提供者更是。人是生产内容的主题，当时间作为一个新的经济维度的时候，知识和时间的糅合，便让付费随后呼之欲出。 理想的方式是订阅者通过付费订阅能够获得自己需要的知识，技能指导，理论讲解，而知识内容的提供者能够从中获取物质上的收益，个人能力的总结和拓展，提问本身更加促进提供者在有限的时间里对自身能力水平的提高，同时又张大了人脉圈。优质回答有促进了内容提供者在订阅者圈子的口碑，获得潜在的宣传和推广，从而吸引更多的人加入圈子。当然，这是理想的生态模式。 知识的商业化，其实是一直都存在着的。比如版权，专利。知识的的确确提高了生产力，促进了社会的发展。对知识本身的获取和利用，和我们对生产资料的使用观应该等同的。经济发展，我们讲究可持续的良性健康的发展道路。姑且拿豆腐来举例:它爸爸是黄豆，从进入泥土那一刻，便开始吸收雨露营养，发芽沐浴接触阳光和流动的空气，到授粉结果，勉强划为第一个阶段的话，这就是知识的吸收和成长的阶段，从肥沃土壤中和滋润的空气里获取到的营养，用来生根，发芽，生长，开花和结果，这是储备阶段；第二个阶段，便是 “变现”，嫩青绿的黄豆是烧烤摊上的一顿美味，晒干的豆粒可以作为种子，也可以做成各种各样的食物：黄豆酱，豆腐。我们再拿豆腐来说，磨制豆腐过程中，可以拿出一部分作为豆浆作为早餐，一部分作为嫩豆腐，时间久点的做成口感不同的老豆腐，剩下的豆腐渣和秸秆可以是猪牛羊的饲料，也可以化作春泥更护花。诺，你看到了，多么自然的体会。人和知识结合时间作为一个整体来对待，也是同样经历。成长阶段不断地从周围获取营养物质，成长自身，等到丰满羽翼的时候，积累到了一定的储备，那就应该拿出来创造价值。 片面的说，在近期内，就足够让一拨人走上小康，因为这个时代，你如果想要赚点外快，其实并不难。前提是，你真有一技之长。 知识付费，反映了一定程度的社会诉求：通过交换，买卖双方都能得到自己想要的东西。知识付费提高了知识的生产动力，在商业化的道路上将会有一段泥泞的道路要走，如果有一类人执意要走的话。现实永远是复杂的，理念永远是美好的。 （本文完）","categories":[{"name":"热点思考","slug":"热点思考","permalink":"https://eyea.github.io/blog/categories/热点思考/"}],"tags":[{"name":"知识付费、变现","slug":"知识付费、变现","permalink":"https://eyea.github.io/blog/tags/知识付费、变现/"},{"name":"知识共享","slug":"知识共享","permalink":"https://eyea.github.io/blog/tags/知识共享/"}]},{"title":"哆啦A梦","slug":"哆啦A梦","date":"2017-01-20T02:01:30.000Z","updated":"2019-04-18T08:35:31.195Z","comments":true,"path":"2017/01/20/哆啦A梦/","link":"","permalink":"https://eyea.github.io/blog/2017/01/20/哆啦A梦/","excerpt":"使用CSS3属性来画出一个哆啦A梦;下面是代码的简单实现，以及用到的一些属性介绍。","text":"使用CSS3属性来画出一个哆啦A梦;下面是代码的简单实现，以及用到的一些属性介绍。 图片结构拆分我们大致的把这个胖子分成两部分，head和body，当然也把双脚也加上。123456789101112131415161718192021222324252627282930313233343536&lt;div class=\"fat_pet\"&gt; &lt;!-- head part --&gt; &lt;header class=\"pet_head\"&gt; &lt;!-- eyes --&gt; &lt;div class=\"left_eye\"&gt;&lt;/div&gt; &lt;div class=\"right_eye\"&gt;&lt;/div&gt; &lt;!-- mustache --&gt; &lt;div class=\"left_mustache\"&gt;&lt;/div&gt; &lt;div class=\"right_mustache\"&gt;&lt;/div&gt; &lt;!-- mouth --&gt; &lt;div class=\"mouth\"&gt;&lt;/div&gt; &lt;/header&gt; &lt;!-- pet_collar --&gt; &lt;div class=\"pet_collar\"&gt; &lt;div class=\"pet_bell\"&gt; &lt;div class=\"pet_bell_wig\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- pet_body --&gt; &lt;section class=\"pet_body\"&gt; &lt;!-- pet_belly --&gt; &lt;div class=\"pet_belly\"&gt;&lt;/div&gt; &lt;!-- pet_waist --&gt; &lt;div class=\"pet_waist\"&gt;&lt;/div&gt; &lt;!-- pet_arms --&gt; &lt;div class=\"pet_arms\"&gt; &lt;div class=\"left_arm\"&gt;&lt;/div&gt; &lt;div class=\"right_arm\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- pet_footer --&gt; &lt;div class=\"pet_footer\"&gt; &lt;div class=\"left_foot\"&gt;&lt;/div&gt; &lt;div class=\"right_foot\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们先给整个身体一个站立的空间，命名为”fat_pet”。 脑袋大脑袋要给点特殊的配置，比如CSS3的 after,before…等这些伪元素.伪元素的语法是这样子的：1selector:pseudo-element &#123;property:value;&#125; 常见的伪元素以及例子： eg:1 first-line p 元素的第一行文本 12345678910p:first-line &#123; color:#ff0000; font-variant:small-caps; &#125;// \"first-line\" 伪元素只能用于块级元素。// 块级元素？DIV P ...// 行内元素？span img ...// 区别是// 应用于 \"first-line\" 伪元素属性：font color background line-height word-spacing(字间距) letter-spacing(字母间距) eg:2 :first-letter 向文本的首字母设置特殊样式 1234567p:first-letter &#123; color:#ff0000; font-size:20px; &#125;// \"first-letter\" 伪元素只能用于块级元素。//属性可应用于 \"first-letter\" 伪元素：font color background margin padding border line-height eg:3 :before 伪元素可以在元素的内容前面插入新内容。在元素内容的最前面插入生成内容。默认地，这个伪元素是行内元素，不过可以使用属性 display 改变这一点。这个点在我们这个例子里会用到，稍微重点聊一下：content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容(PS:本次应用的是content插入无内容的行内元素来进行线条的绘制)点击这里查看：关于content的一篇文章 说点相关的还有伪类，对应的语法：1selector : pseudo-class &#123;property: value&#125; 应用常见是我们的a元素：1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 顺序一定要是l-v-h-a，否则可能不生效；记忆的方法两个单词：l-o-v-e，ha-t-e。伪类可以与 CSS 类配合使用：123a.red : visited &#123;color: #FF0000&#125;&lt;a class=\"red\" href=\"css_syntax.asp\"&gt;CSS Syntax&lt;/a&gt;//链接被访问过，那么它将显示为红色。 另外还有伪类比如:first-child ，简单举几个例子： eg:1,选择器匹配作为任何元素的第一个子元素的 p 元素： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;p:first-child &#123; color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; eg:2 选择器匹配所有 p 元素中的第一个 i 元素： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;p &gt; i:first-child &#123; font-weight:bold; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt;&lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; eg：3选择器匹配所有作为元素的第一个子元素的 p 元素中的所有 i 元素： 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;p:first-child i &#123; color:blue; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt;&lt;p&gt;some &lt;i&gt;text&lt;/i&gt;. some &lt;i&gt;text&lt;/i&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 此外还有 :focus元素获得焦点时向元素添加特殊的样式等。下面是大脑袋的html部分：1234567891011&lt;!-- head part --&gt;&lt;header class=\"pet_head\"&gt; &lt;!-- eyes --&gt; &lt;div class=\"left_eye\"&gt;&lt;/div&gt; &lt;div class=\"right_eye\"&gt;&lt;/div&gt; &lt;!-- mustache --&gt; &lt;div class=\"left_mustache\"&gt;&lt;/div&gt; &lt;div class=\"right_mustache\"&gt;&lt;/div&gt; &lt;!-- mouth --&gt; &lt;div class=\"mouth\"&gt;&lt;/div&gt;&lt;/header&gt; 开始实现的css：1.脑袋跟眼睛和鼻子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* pet_head */.pet_head&#123; margin: 0 auto; width: 300px; height: 300px; border-radius: 50%; border: 2px solid #000; position: relative; background: linear-gradient(45deg,#095469,#095469,#0EAFD9,#0EAFD9,#0EAFD9,#0EB7E2,#0BBCE8, #82DEF7,#82DEF7)&#125;/*这里大家看到了跟以往看到的一点点不同，background一般我们用这个属性添加背景图、背景色等，这里我们用到的是css3的一个线性渐变属性：CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）;[linear-gradient介绍](http://blog.csdn.net/she_rryn/article/details/50454153);注意在不同浏览器下的兼容性;*/.pet_head::after&#123; position: absolute; bottom: 6px; left: 25px; width: 250px; height: 200px; border-radius: 50%; border: 2px solid #000; content: ''; background: #fff;&#125;.pet_head .left_eye,.pet_head .right_eye&#123; width: 60px; height: 78px; position: absolute; top: 40px; z-index: 1; background: #fff; border: 2px solid #000; border-radius: 46%;&#125;.pet_head .left_eye&#123; left: 84px;&#125;.pet_head .left_eye::before,.pet_head .right_eye::before&#123; content: ''; width: 18px; height: 18px; position: absolute; bottom: 18px; background: #000; border-radius: 50%;&#125;.pet_head .left_eye::before&#123; right: 10px;&#125;.pet_head .right_eye&#123; right: 90px;&#125;.pet_head .right_eye::before&#123; left: 10px;&#125;.pet_head .left_eye::after&#123; content: ''; width: 25px; height: 25px; position: absolute; top: 68px; left: 46px; background: red; border: 2px solid #000; border-radius: 50%;&#125; 2.同时两边的胡子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* mustache */.pet_head .left_mustache,.pet_head .right_mustache&#123; position: absolute; bottom: 130px; width: 60px; height: 2px; background: #000; z-index: 1;&#125;.pet_head .left_mustache&#123; left: 58px;&#125;.pet_head .left_mustache::before,.pet_head .left_mustache::after,.pet_head .right_mustache::before,.pet_head .right_mustache::after&#123; content: ''; width: 60px; height: 2px; position: absolute; left: 0px; background: #000; z-index: 1;&#125;.pet_head .left_mustache::before&#123; bottom: 10px; transform-origin: right; transform: rotate(30deg);/*顺时针*/&#125;/*这里有个transform属性transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转(rotate)、缩放(scale)、移动(translateX)或倾斜(skewY)。[transform](http://www.w3school.com.cn/cssref/pr_transform.asp);*/.pet_head .left_mustache::after&#123; bottom: -10px; transform-origin: right; transform: rotate(-30deg);&#125;/*右侧胡须处理*/.pet_head .right_mustache&#123; right: 58px;&#125;.pet_head .right_mustache::before&#123; top: 10px; transform-origin: left; transform: rotate(30deg);&#125;.pet_head .right_mustache::after&#123; top: -10px; transform-origin: left; transform: rotate(-30deg);&#125; 3.嘴巴跟笑脸123456789101112131415161718192021/* mouth */.pet_head .mouth&#123; width: 2px; height: 118px; background: #000; position: absolute; bottom: 45px; left: 146px; z-index: 1;&#125;.pet_head .mouth::after&#123; content: ''; width: 150px; height: 80px; position: absolute; bottom: -2px; left: -75px; z-index: 1; border-bottom: 2px solid #000; border-radius: 50%;&#125; 铃铛12345&lt;div class=\"pet_collar\"&gt; &lt;div class=\"pet_bell\"&gt; &lt;div class=\"pet_bell_wig\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面是实现红色的领带跟小铃铛的html代码。来看我们对应的css部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* collar */.pet_collar&#123; position: relative; width: 280px; height: 24px; background: red; margin: -28px auto 0px auto; border: 2px solid #000; border-radius: 10px; z-index: 5;&#125;.pet_bell&#123; position: absolute; top: 15px; left: 120px; width: 40px; height: 40px; background: #CBC10A; border-radius: 50%; border: 2px solid #000;&#125;.pet_bell::before,.pet_bell::after&#123; content: ''; background: #000; width: 38px; height: 2px; position: absolute; top: 10px;&#125;.pet_bell::after&#123; width: 40px; top: 14px;&#125;.pet_bell_wig&#123; position: absolute; bottom: 8px; left: 12px; background: #000; width: 16px; height: 12px; border-radius: 50%;&#125;.pet_bell_wig::after&#123; content: ''; background: #000; width: 4px; height: 10px; position: absolute; bottom: -8px; left: 6px;&#125; 身体部分肚子部分我们分成了这么几个部分：蓝胖子的大肚子，一双肥胖的双手，两条大粗腿跟一双44尺码的脚。123456789101112&lt;!-- pet_body --&gt;&lt;section class=\"pet_body\"&gt; &lt;!-- pet_belly --&gt; &lt;div class=\"pet_belly\"&gt;&lt;/div&gt; &lt;!-- pet_waist --&gt; &lt;div class=\"pet_waist\"&gt;&lt;/div&gt; &lt;!-- pet_arms --&gt; &lt;div class=\"pet_arms\"&gt; &lt;div class=\"left_arm\"&gt;&lt;/div&gt; &lt;div class=\"right_arm\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 下面在进一步细分: 肚子12&lt;!-- pet_belly --&gt;&lt;div class=\"pet_belly\"&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*先给个父元素相对定位，方便我们把蓝胖子的肚子、双手、膝盖放到合适的位置*//* pet_body */.pet_body&#123; position: relative; width: 240px; height: 200px; margin: 0 auto;&#125;/*肚子*/.pet_belly&#123; width: 240px; height: 180px; background: #fff; margin: 0 auto; border: 2px solid #000; border-radius: 48%; position: absolute; top: -10px; z-index: 4;&#125;/*使用before after*/.pet_belly::before&#123; content: ''; width: 130px; height: 130px; border: 2px solid #000; border-radius: 50%; position: absolute; top: 10px; left: 55px; border-top-color: transparent; border-right-color: transparent; transform: rotate(-45deg);&#125;.pet_belly::after&#123; content: ''; width: 134px; height: 2px; background: #000; position: absolute; top: 76px; left: 55px;&#125; 左右手12345&lt;!-- pet_arms --&gt;&lt;div class=\"pet_arms\"&gt; &lt;div class=\"left_arm\"&gt;&lt;/div&gt; &lt;div class=\"right_arm\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* pet_arms *//*同样的两只手同时画 给出大体位置*/.pet_arms&#123; position: absolute; top: 0; left: -20px; background: linear-gradient(85deg,#0C90B3,#0C90B3,#0EAFD9,#0DBAE5,#0DBAE5); width: 280px; height: 60px;&#125;.left_arm,.right_arm&#123; width: 100px; height: 50px; background: #0C90B3; position: absolute; border: 2px solid #000; z-index: 1;&#125;/*拆分*/.left_arm&#123; left: -60px; top: 20px; border-right: none; transform: rotate(-45deg);&#125;.right_arm&#123; right: -60px; top: 20px; background: #0DBAE5; border-left: none; transform: rotate(45deg);&#125;.right_arm::before&#123; left: 84px; bottom: -14px;&#125;/*两个手掌*/.left_arm::before,.right_arm::before&#123; content: ''; width: 80px; height: 80px; border-radius: 50%; border: 2px solid #000; background: #fff; position: absolute;&#125;.left_arm::before&#123; right: 84px; bottom: -14px;&#125; 膝盖12&lt;!-- pet_waist --&gt;&lt;div class=\"pet_waist\"&gt;&lt;/div&gt; 12345678910111213/* pet_waist */.pet_waist&#123; position: absolute; top: 45px; height: 180px; width: 276px; margin-left: -20px; background: linear-gradient(45deg,#0C90B3,#0C90B3,#0C90B3,#0EAFD9,#0EB7E2,#0BBCE8); border-left: 2px solid #000; border-right: 2px solid #000; border-bottom: 2px solid #000; z-index: 3;&#125; 双脚12345&lt;!-- pet_footer --&gt;&lt;div class=\"pet_footer\"&gt; &lt;div class=\"left_foot\"&gt;&lt;/div&gt; &lt;div class=\"right_foot\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920/* pet_footer */.pet_footer&#123; position: relative; top: 22px; width: 300px; margin: 0 auto; z-index: 5;&#125;.left_foot,.right_foot&#123; width: 146px; height: 40px; background: #fff; border: 2px solid #000; border-radius: 40px; position: absolute;&#125;.right_foot&#123; left: 146px; margin-left: 10px;&#125; 最后，少点东西：12345678910111213141516/*使用伪元素after或者before好让蓝胖子的腿没那么粗*/.pet_waist::after&#123; content: ''; width: 30px; height: 30px; background: #fff; border: 2px solid #000; border-radius: 50%; border-top: none; border-right: none; transform: rotate(135deg); position: absolute; bottom: -15px; left: 50%; margin-left: -15px;&#125; Tips这次涉及到的此时CSS3的知识点有： before,after –&gt; 纯css3小demo演示 ⬇️ content:””; background:linear-gradient(); transform:rotate(); 更多css3小demo （本文完）","categories":[{"name":"CSS","slug":"CSS","permalink":"https://eyea.github.io/blog/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://eyea.github.io/blog/tags/CSS/"}]},{"title":"GIT基本命令合集","slug":"GIT基本命令合集","date":"2017-01-14T03:54:49.000Z","updated":"2019-04-18T08:35:31.195Z","comments":true,"path":"2017/01/14/GIT基本命令合集/","link":"","permalink":"https://eyea.github.io/blog/2017/01/14/GIT基本命令合集/","excerpt":"git操作是我们每个coder应该熟练掌握的一项生存技能，Anywhere &amp;&amp; Anyone…好了，闲话少扯，直接开始撸.","text":"git操作是我们每个coder应该熟练掌握的一项生存技能，Anywhere &amp;&amp; Anyone…好了，闲话少扯，直接开始撸. 每天进步一点点 新建代码库123456# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户住目录下（全局配置），也可以在项目目录下（项目配置）1234567# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112131415# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345678910111213# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支1234567891011121314151617181920212223242526272829# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签123456789101112131415161718# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息1234567891011121314151617181920212223242526272829303132333435363738394041# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步12345678910111213141516# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 未完待补充… ^_^","categories":[{"name":"Tools","slug":"Tools","permalink":"https://eyea.github.io/blog/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://eyea.github.io/blog/tags/Git/"}]},{"title":"Ajax跨域请求方案","slug":"前端ajax跨域请求方案","date":"2017-01-09T14:26:01.000Z","updated":"2019-04-18T08:35:31.193Z","comments":true,"path":"2017/01/09/前端ajax跨域请求方案/","link":"","permalink":"https://eyea.github.io/blog/2017/01/09/前端ajax跨域请求方案/","excerpt":"1.所谓跨域跨域是一种浏览器同源安全策略，也即浏览器单方面限制脚本的跨域访问。很多人可能误认为资源跨域时无法请求，实质上请求是可以正常发起的（指通常情况下，部分浏览器存在部分特例），后端也可能正常进行了处理，只是在返回时被浏览器所拦截。可以论证这一点的著名案例就是CSRF跨站攻击。另外，所谓跨域都是在讨论浏览器行为，包括各种webview容器，其中犹以 XmlHttpRequest 为主。正是由于javascript跑在浏览器之上，所以ajax的跨域成了痛点。","text":"1.所谓跨域跨域是一种浏览器同源安全策略，也即浏览器单方面限制脚本的跨域访问。很多人可能误认为资源跨域时无法请求，实质上请求是可以正常发起的（指通常情况下，部分浏览器存在部分特例），后端也可能正常进行了处理，只是在返回时被浏览器所拦截。可以论证这一点的著名案例就是CSRF跨站攻击。另外，所谓跨域都是在讨论浏览器行为，包括各种webview容器，其中犹以 XmlHttpRequest 为主。正是由于javascript跑在浏览器之上，所以ajax的跨域成了痛点。 2.跨域形成请求的url与当前页面不同即产生跨域，除常理上的站点直接性不同（百度域名下访问谷歌资源），同个站点也可以产生跨域：协议跨域，例如从 http 站点访问 https 站点。主机跨域，例如从 a.baidu.com 访问 b.baidu.com端口跨域，例如从80端口的站点访问8080端口的站点。请求域名和直接请求该域名对应的ip之间也算跨域。内部判断规则：url首部匹配1window.location.protocol + window.location.host 简单性的将协议、主机名和端口号抽出进行对比，不同即跨域，所以也是不会去转化为ip地址的。 3.跨域方案之Jsonp谈起Jsonp在跨域处理方案中也算鼎鼎大名，这是一种非官方的解决方案，源于浏览器允许一些带src属性的标签跨域，例如iframe、script、img等。而Jsonp即是利用了script加载外部脚本的功能。例如常规下的请求1234567891011get =&gt; http://a.test.com/users=&gt;&gt;[&#123; username : &apos;沐心chen&apos;, sex : &apos;男&apos;, address : &apos;广东深圳&apos;&#125;,&#123; username : &apos;李彦宏&apos;, sex : &apos;男&apos;, address : &apos;山西阳泉&apos;&#125;] 由于浏览器的同源策略被阻止，此时前端使用script脚本去加载：1&lt;script src=&quot;http://a.test.com/users&quot;&gt;&lt;/script&gt; 显然可以成功请求到，只是单纯的json数据无法使用。此时如果后端介入，返回之前包装成如下形式：123456789jsonp([&#123; username : &apos;沐心chen&apos;, sex : &apos;男&apos;, address : &apos;广东深圳&apos;&#125;,&#123; username : &apos;李彦宏&apos;, sex : &apos;男&apos;, address : &apos;山西阳泉&apos;&#125;] 对于js而言，这就是一个普通的函数调用1jsonp(...params) 那么只要前端定义jsonp这个函数，它就会被执行并传入json数据。1234var jsonp = function(data)&#123; //输出json console.dir(data);&#125; jsonp跨域的流程走完，只是单纯到这一步还不行，因为它将导致后端无法正确处理非jsonp的请求，所以通常会约定一个参数callback，带上回调的函数名。1&lt;script src=&quot;http://a.test.com/users?callback=jsonp&quot;&gt;&lt;/script&gt; 后端得到callback参数时，使用该值包装json数据，否则正常处理。需要注意的是，处理jsonp的函数必须在window下，也即123window.jsonp = function(data)&#123; console.dir(data);&#125; 方案虽然可行，但也同时意味着jsonp只能发起get请求，对于post就无能为力了。知道了原理，使用起来相对还是麻烦，那么如何用js简单封装一个jsonp方案呢？1234567891011121314151617181920212223var getJsonp = function(url, success)&#123; //声明window下的jsonp函数 window.jsonp = function(data)&#123; //jsonp函数被执行将data转发到success函数 success(data); &#125; var src = &apos;&apos;; //判断地址是否带其它参数决定callback怎么拼接 if(url.IndexOf(&apos;?&apos;) != -1)&#123; src = url + &apos;&amp;callback=jsonp&apos;; &#125;else&#123; src = url + &apos;?callback=jsonp&apos;; &#125; //动态创建script标签 var script = document.createElement(&apos;script&apos;); script.type = &quot;text/javascript&quot;; script.src = src; document.head.appendChild(script);&#125;//用法getJsonp(&apos;http://test.com/users&apos;, function(data)&#123; console.log(&apos;得到jsonp数据：&apos;,JSON.stringify(data));&#125;); 上面只是一个简单的封装思路，如果需要做的更好可以允许指定callback，还可以在回调函数之后销毁script脚本，这些留给大家去发挥（思考一下，如果每个开发者都统一用callback，你可以跨域访问，别人也可以跨域访问，安全上面起不到更好的保障，与后端协议好一个自定义的参数，将能稍微避免一些，当然，所谓安全大都只是防范君子）。浏览器支持：几乎所有 4.跨域解决方案之CORSCORS，也即 Cross-Origin Resource Sharing（跨域资源共享），它需要现代浏览器的支持，是一种更安全的官方解决方案。CORS使得以下常见场景得到支持：使用 XMLHttpRequest 或 Fetch 发起跨站 HTTP 请求。web 字体(css 中通过 @font-face 使用跨站字体资源)使用 drawImage 绘制 Images/video 画面到 canvasCORS有以下三种常见的访问控制场景：简单请求只使用 GET 、HEAD 或者 POST 发起请求，如果使用 POST ，那么其数据类型( Content-Type )只能是 application/x-www-form-urlencoded、 multipart/form-data 或 text/plain中的一种。不使用自定义请求头这种请求跟正常的ajax请求几乎没有差异，只是浏览器会在请求头中自动添加一个origin属性，内容为本页面地址。例如我们使用 XMLhttprequest 正常发起一个 GET 请求，源站点为my.com，目标站点为test.com，浏览器实际发出的请求头如下：123GET /resources/public-data/ HTTP/1.1...Origin: http://my.com 此时浏览器维持判断，当服务端返回的响应头中，存在跨域访问控制属性并匹配本次请求，则跨域成功（正常接收数据）。123HTTP/1.1 200 OK...Access-Control-Allow-Origin: http://my.com 这种跨域请求非常简单，只需要后端在返回的响应头中添加Access-Control-Allow-Origin属性并将被允许的站点填入即可（多个站点逗号隔开，允许所有站点则设为*）预请求预请求不同于简单请求，它首先会发送一个 OPTIONS 请求到目标站点，以查明该请求是否安全可接受，以防止请求对目标站点的数据造成破坏。当请求具备以下条件，就会被当成预请求处理：请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded , multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 数据的请求。使用自定义请求头例：12345678910111213141516var request = new XMLHttpRequest();var url = &apos;http://test.com/users&apos;;var body = &apos;test&apos;;function coAccess()&#123; if(request) &#123; request.open(&apos;POST&apos;, url, true); request.setRequestHeader(&apos;X-CUSTOMER-HEADER&apos;, &apos;沐心chen&apos;); request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;); request.onreadystatechange = function(state)&#123; ... &#125;; request.send(body); &#125; ... 上面发送了一个 POST 请求，请求数据类型为application/xml，并携带一个自定义请求头X-CUSTOMER_HEADER，符合预请求的规范。此时浏览器与后端的交互过程如下：123456789101112131415161718192021222324252627//浏览器预先发起OPTIONS请求，自动添加Origin、Access-Control-Request-Method和Access-Control-Request-HeadersOPTIONS /resources/post-here/ HTTP/1.1...Origin: http://my.comAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-CUSTOMER-HEADER//后端接收OPTIONS请求，返回响应头中包含Access-Control-Allow-策略和Access-Control-Max-Age时限HTTP/1.1 200 OK...Access-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, DELETE, UPATE, PATCH, OPTIONSAccess-Control-Allow-Headers: X-CUSTOMER-HEADERAccess-Control-Max-Age: 1728000Vary: Accept-Encoding, Origin//浏览器判断本次请求被允许，真实发起原先的POST请求POST /resources/post-here/ HTTP/1.1...X-CUSTOMER-HEADER: 沐心chenOrigin: http://my.com//服务器返回数据HTTP/1.1 200 OK...Access-Control-Allow-Origin: http://my.comVary: Accept-Encoding, Origin OPTIONS是一个理论上不应该对服务端数据造成影响的请求方式。响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET, DELETE, UPATE, PATCH, OPTIONS的请求方法,而Access-Control-Max-Age则告诉浏览器本次预请求的有效期为20天，在这段时间内针对该站点的请求都不需要再预先发起OPTIONS请求。带凭证的请求跨站请求一般而言，是不会携带cookie和其它凭证的，但 CORS 允许这样做。1234567891011121314var request = new XMLHttpRequest();var url = &apos;http://test.com/users&apos;;function coAccess()&#123; if(request) &#123; request.open(&apos;GET&apos;, url, true); request.withCredentials = true; request.onreadystatechange = function(state)&#123; ... &#125;; request.send(body); &#125; ... 我们在request中将withCredentials设置为true，使得该请求携带cookie和凭证，此时服务端必须在响应头中声明Access-Control-Allow-Credentials为true，否则响应体将被浏览器忽略。12345678910111213//浏览器发起请求，携带cookie信息GET /resources/access-control-with-credentials/ HTTP/1.1...Origin: http://my.comCookie: rememberMe=沐心chen//服务端返回，设置了更多cookieHTTP/1.1 200 OK...Access-Control-Allow-Origin: http://my.comAccess-Control-Allow-Credentials: trueVary: Accept-Encoding, OriginSet-Cookie:rememberYou=沐心chen 值得一提的是，带凭证的请求要求服务端具体设置Access-Control-Allow-Origin的值而不允许使用，否则响应也会被浏览器忽略。如果一切正常，跨域访问将同时允许cookie的读和写。上面一直没提的一个响应头属性是 Vary，顺带提及一下，如果我们的跨域方案不需要cookie参与，那么Access-Control-Allow-Origin 是允许设置为 的，但如果我们具体的去设置它的允许域名，则需要后端在响应头再设置一个 Vary 参数，值为 Accept-Encoding, Origin ，它告诉浏览器，响应是根据请求头里的Origin的值来返回不同的内容的。尽管 CORS 需要现代浏览器的支持，但几乎不用关心这个问题，因为大部分目前仍存活的浏览器都有作出实现，对于前端来说可能最多是设置允许携带凭证，其它的工作就解放到后端了。浏览器支持：123456Destop MobileIE8+ Android2.1Chrome4+ Safari3.2firefox3.5+ 其它Opera12+ ..Safari4+ .. （本文完）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://eyea.github.io/blog/categories/JavaScript/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://eyea.github.io/blog/tags/Ajax/"}]},{"title":"HTML5---localStorage本地存储","slug":"html之localStorage","date":"2017-01-04T16:33:03.000Z","updated":"2019-04-18T08:35:31.203Z","comments":true,"path":"2017/01/05/html之localStorage/","link":"","permalink":"https://eyea.github.io/blog/2017/01/05/html之localStorage/","excerpt":"概述HTML5 提供了两种在客户端存储数据的新方法：localStorage - 没有时间限制的数据存储sessionStorage - 针对一个 session 的数据存储","text":"概述HTML5 提供了两种在客户端存储数据的新方法：localStorage - 没有时间限制的数据存储sessionStorage - 针对一个 session 的数据存储之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。HTML5 使用 JavaScript 来存储和访问数据。 用法小结（一）设置值1231.localStorage.setItem(key,value) //如果key的value存在时，更新key的值,例：localStorage.setItem(\"name\",\"moomoo\");【推荐写法】2.localStorage.name = \"moomoo\";3.localStorage[\"name\"] = \"moomoo\"; （二）获取值1231.localStorage.getItem(key,value):如果key的value不存在时，返回null，例：localStorage.getItem(\"name\");【推荐写法】2.var name = localStorage.name;3.var name = localStorage[\"name\"]; （三）清除值121.localStorage.remove(key);// 表示清除单项key的值，例:localStorage.remove(\"name\");执行这句话就会清除name的值2.localStorage.clear(); // 表示清除localStorage存储的所有数据 （四）遍历存储的数据当你不清楚本地localStorage存储了多少数据的时候，用key(index)方法绝对是一个不错的选择，key(index)方法可以遍历localStorage存储的key。写个简单的例子：123456for(i=0;i&lt;localStorage.length;i++)&#123; document.write(localStorage.key(i)+\":\"+localStorage.getItem(localStorage.key(i))+\"&lt;br/&gt;\");&#125;localStorage.length表示本地存储数据的总量；localStorage.key(i),表示获取第i个数据的key；localStorage.getItem(localStorage.key(i));表示获取第i个数据的value。 （五）JSON存储当需要存储的数据很多时，可以将数据存储到数组中并转换成JSON格式的数据。1.SON.stringify(data) 将对象转换成JSON格式的数据串。2.JSON.parse(data)将数据解析成对象并返回解析后的对象。这样说或许不太好懂，直接上例子：123var arr = &#123;\"name\":\"moomoo\",\"age\":2,\"eat\":\"apple\"&#125;;localStorage.setItem(\"arr\",JSON.stringify(arr));arr = JSON.parse(localStorage.getItem(\"arr\")); 不过需要注意的是：localStorage存储的数据是不能跨浏览器共用的，也就是说存储在浏览器的数据只能在这个浏览器中访问，现在各个浏览器的存储空间是5M。（六）sessionStoragesessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话，也就是说sessionStorage针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。当浏览器被意外刷新的时候，一些临时数据应当被保存和恢复。sessionStorage 对象在处理这种情况的时候是最有用的。sessionStorage自动保存一个文本域中的内容，如果浏览器被意外刷新，则恢复该文本域中的内容，所以不会丢失任何输入的数据。sessionStorage 方法与localStorage的方法相似，这里就不过多赘述。（七）兼容性 点击这里查看兼容性^_^作者 @eyea END","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://eyea.github.io/blog/categories/性能优化/"}],"tags":[]},{"title":"开始新篇章","slug":"night","date":"2017-01-04T16:27:18.000Z","updated":"2019-04-18T08:35:31.203Z","comments":true,"path":"2017/01/05/night/","link":"","permalink":"https://eyea.github.io/blog/2017/01/05/night/","excerpt":"一枚前端，在努力得一步一步往上爬","text":"一枚前端，在努力得一步一步往上爬更多精彩内容，后续会持续更新中…^_^","categories":[{"name":"阅读","slug":"阅读","permalink":"https://eyea.github.io/blog/categories/阅读/"}],"tags":[]}]}